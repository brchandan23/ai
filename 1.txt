CI/CD Pipeline with Jenkins, Docker, Kubernetes, and Docker Swarm
This document outlines the complete workflow for developing, containerizing, and deploying both a Flask and a Maven Spring Boot application using a Jenkins CI/CD pipeline and Minikube.

1. Application Setup & Local Development
Flask Web Application
Initialize Directory: Create a folder named my_webapp and navigate into it.

app.py: Create the application entry point.

from flask import Flask
app=Flask(__name__)

@app.route("/")
def home():
	return "Hello from Jenkins Pipeline Demo"

if __name__ == "__main__":
	app.run(host='0.0.0.0', port=5000)
requirements.txt: Define the dependencies.
flask
Dockerfile: Configure the container image.
FROM python:3.10-slim
WORKDIR /app
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt
COPY . .
EXPOSE 5000
CMD ["python","app.py"]
Local Testing: Build and run the Docker image locally to verify.
docker build -t my_webapp .
docker run -p 5000:5000 my_webapp:latest
Maven Spring Boot Application
Project Generation: Use Spring Initializr to generate a Maven project.

Project: Maven Project
Language: Java
Spring Boot: Latest version
Project Metadata:
Group: com.example
Artifact: my_maven_app
Name: my_maven_app
Description: Demo project for Spring Boot
Package name: com.example.my_maven_app
Packaging: Jar
Java: 21
Dependencies: Add "Spring Web"
Click Generate to download the ZIP file.
Extract the ZIP file into your working directory.

HomeController.java: Add a rest controller at src/main/java/com/example/my_maven_app/.

package com.example.my_maven_app;

import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
public class HomeController {
    @GetMapping("/")
    public String home() {
        return "Hello from Spring Boot Maven App!";
    }
}
Local Build: Install Maven and build the project while skipping tests.
sudo apt install maven
mvn clean package -DskipTests
Dockerfile: Configure the container for the Java application.
FROM eclipse-temurin:21-jdk-alpine
WORKDIR /app
COPY target/*.jar app.jar
EXPOSE 8080
CMD ["java","-jar","app.jar"]
Local Testing: Build and run the Docker image locally to verify.
docker build -t my_maven_app .
docker run -p 10000:8080 my_maven_app:latest
Open localhost:10000 in your browser to verify the application displays "Hello from Spring Boot Maven App!".
React Web Application
Initialize Directory: Create a folder named my_react_app and navigate into it.

Create React App: Use Create React App to scaffold the application.

npx create-react-app .
Customize App: Edit src/App.js to add custom content (e.g., a welcome message).
import React from 'react';

function App() {
  return (
    <div className="App">
      <header className="App-header">
        <h1>Hello from React CI/CD Pipeline Demo</h1>
      </header>
    </div>
  );
}

export default App;
Build the App: Compile the React app for production.
npm run build
Dockerfile: Configure the container image using Nginx to serve the built app.
FROM nginx:alpine
COPY build /usr/share/nginx/html
EXPOSE 80
CMD ["nginx", "-g", "daemon off;"]
Local Testing: Build and run the Docker image locally to verify.
docker build -t my_react_app .
docker run -p 3000:80 my_react_app:latest
Open localhost:3000 in your browser to verify the React app loads.
2. Source Control & Repository Configuration
GitHub Initialization
For both applications, initialize a local Git repository and push to GitHub.

Git Init:
git init
git branch -m main
git add .
git commit -m "Initial Commit"
Remote Setup: Create a new repository on GitHub and link it locally.
git remote add origin <ssh-url-of-github-repo>
SSH Authentication: Generate an SSH key and add the public key to your GitHub account settings.
ssh-keygen -t ed25519 -C "<your-email>"
cat ~/.ssh/id_ed25519.pub
ssh -T git@github.com # Test connection
Push Code:
git push origin main
Alternative: Using Fine-Grained Personal Access Token (HTTPS)
If you prefer not to use SSH, you can use a fine-grained personal access token for authentication.

Generate Token: Go to GitHub Settings > Developer settings > Personal access tokens > Fine-grained tokens. Create a new token with repository permissions (e.g., Contents: Read and write).

Remote Setup: Use the HTTPS URL instead of SSH.

git remote add origin https://github.com/<username>/<repo>.git
Push Code: When pushing, enter your GitHub username and the token as the password.
git push origin main
# Enter username and token when prompted
For automation, you can configure Git to store credentials, but be cautious with security.
Docker Hub Setup
Log in to Docker Hub and create new repositories named my_webapp and my_maven_app.
3. Jenkins CI/CD Pipeline Configuration
Plugin & System Requirements
Install Plugins: Ensure the following are installed: Git, Pipeline, Docker Pipeline, and Credential Binding.

Restart Jenkins: sudo systemctl restart jenkins.

Permissions: Add the Jenkins user to the Docker group to allow command execution.

sudo usermod -aG docker jenkins
sudo systemctl restart docker
sudo systemctl restart jenkins
Credentials & Security
Docker Hub Credentials: Go to Manage Jenkins > Credentials > Global > Add Credentials. Select "Username and Password," use the ID dockerhub, and enter your Docker Hub credentials.

GitHub Access for Jenkins (Optional for Public Repos):

Jenkins only needs to pull (clone) the repository code for building and does not push back to GitHub. Only Docker Hub push occurs.

For Public Repositories: No authentication is required. Jenkins can clone the repo directly using the HTTPS URL without credentials.

For Private Repositories or to Avoid Rate Limits: Configure authentication as follows:

SSH Method:
Switch to the jenkins user: sudo -su jenkins.
Generate an SSH key and add it to GitHub (ensure the key has read access to the repo).
Add GitHub to known hosts:
ssh-keyscan github.com >> ~/.ssh/known_hosts
chmod 600 ~/.ssh/known_hosts
- **Token Method**:
	- Generate a fine-grained personal access token with read-only permissions (e.g., Contents: Read).
	- In Jenkins, go to **Manage Jenkins > Credentials > Global > Add Credentials**. Select "Username and Password," use the ID `github_token`, enter your GitHub username and the token as password.
Jenkinsfile Definitions
Create a jenkinsfile in the root of your project directory.

Flask/Maven/React Pipeline Example:

pipeline {
	agent any
	
// Use only if Cron job is needed, Remove for manual
	triggers {
		cron('H/5 * * * *')  // Runs every 5 minutes
	}
	
	environment {
		DOCKERHUB_CRED=credentials('dockerhub')
		IMAGE_NAME="<docker_hub_username>/<docker_hub_repo_name>"
	}
	
	stages {
		stage('checkout') {
			steps {
				//For Public Repo:
				git url:'https://github.com/<username>/<repo>.git', branch:'main'
				// For SSH: 
				// git url:'<github_repo_ssh_url>', branch:'main'
				// For Token: use HTTPS URL with credentials
				// git url:'https://github.com/<username>/<repo>.git', branch:'main', credentialsId:'github_token'
			}
		}
		
// Stage only for a Maven project, skip for others
		stage('Build Maven Project') {
			steps {
				retry(3) {
					sh "mvn clean package -DskipTests"
				}
			}
		}

// Only for React Project, skip for others
		stage('Install Dependencies and Build React App') {
			steps {
				retry(3) {
					sh 'npm install'
					sh 'npm run build'
				}
			}
		}

// Note: No build stage needed for Flask as it's a simple Python script


		stage('Build Docker Image') {
			steps {
				retry(3) {
					script {
						dockerImage=docker.build("${IMAGE_NAME}:latest")
					}
				}
			}
		}
		
		stage('Push to DockerHub') {
			steps {
				retry(3) {
					script {
						docker.withRegistry('https://index.docker.io/v1/','dockerhub') {
							dockerImage.push()
						}
					}
				}
			}
		}
	}
	
	post {
		success {
			echo "Pipeline Successful"
		}
		failure {
			echo "Pipeline Failed"
		}
		always {
			echo "Cleaning Up WorkSpace"
			deleteDir()
		}
	}
}
Commit and Push the Jenkinsfile: Add the jenkinsfile to Git and push to GitHub.
git add .
git commit -m "Added jenkinsfile"
git push origin main
Pipeline Stage Explanations
For each question, explain the stages during execution:

Checkout Stage: Jenkins clones the repository from GitHub using the specified branch (e.g., main). This pulls the latest code changes.
Build Stages (varies by app):
Flask: Not needed (app is simple).
Maven: mvn clean package -DskipTests compiles and packages the JAR, skipping tests for speed.
React: npm install installs dependencies, npm run build creates production build.
Docker Build Stage: Builds the Docker image using the Dockerfile, tagging it with the IMAGE_NAME.
Push to DockerHub Stage: Logs into Docker Hub and pushes the image for storage and deployment.
Deploy Stage (varies):
Docker Swarm: Uses docker service create or docker stack deploy to run the container on the Swarm cluster.
Kubernetes: Uses kubectl apply to deploy pods/services on the K8s cluster.
Post Actions: Logs success/failure and cleans up the workspace.
For cron-based pipelines, the trigger automatically starts the pipeline at set intervals (e.g., every 5 minutes) without manual intervention.

Creating the Jenkins Pipeline Job
Create New Pipeline Job: Go to Jenkins dashboard > New Item > Pipeline > Enter a name (e.g., my_webapp_pipeline) > OK.

Configure Pipeline:

Under Pipeline section, select Pipeline script from SCM.
SCM: Git.
Repository URL: <https_url_of_github_repo> (for token or no auth) or <ssh_url_of_github_repo> (for SSH).
Credentials: Select credentials if using authentication (optional for public repos).
Branch Specifier: */main.
Script Path: jenkinsfile.
Save and click Build Now.
Verify in Docker Hub
After the pipeline runs successfully, check your Docker Hub repository to confirm the image has been pushed.
4. Kubernetes Deployment with Minikube
Environment Initialization
Install Minikube & Kubectl:
curl -LO https://github.com/kubernetes/minikube/releases/latest/download/minikube-linux-amd64

sudo install minikube-linux-amd64 /usr/local/bin/minikube

minikube start
minikube status
[!NOTE] minikube issue If you encounter issues with the default driver, try specifying --driver=docker in the minikube start command. check with minikube status Delete existing cluster with minikube delete and restart if needed.

sudo snap install kubectl --classic

kubectl version

kubectl cluster-info
Docker Authentication in Minikube:
eval $(minikube docker-env)
docker login
Deployment & Service Management
Create Deployment: Deploy the image from Docker Hub.
kubectl create deployment <app-name> --image=<username>/<repo>:<tag>
Example: kubectl create deployment my-webapp --image=myuser/my_webapp:latest
Expose Port: Make the application accessible.
kubectl expose deployment <app-name> --type=NodePort --port=<app_port>
Flask Example: kubectl expose deployment my-webapp --type=NodePort --port=5000
Maven Example: kubectl expose deployment my-maven-app --type=NodePort --port=8080
React Example: kubectl expose deployment my-react-app --type=NodePort --port=80
Verify Service: Retrieve the URL to access the application.
minikube service <app-name>
This command tunnels the Minikube service to localhost and opens the browser. If it doesn't work, check service status with kubectl get services and pod status with kubectl get pods.
Ensure the app binds to 0.0.0.0 inside the container (already configured in Dockerfiles).
Cleanup:
kubectl delete deployment <app-name>
kubectl delete service <app-name>
minikube stop
Troubleshooting Kubernetes Deployment:
No Access: Ensure minikube service is run in a terminal (it starts a tunnel). Check minikube status and kubectl get pods for running status.
Image Issues: Verify the image exists on Docker Hub and is public or authenticated.
Port Binding: Apps are configured to bind to 0.0.0.0; if custom, ensure Dockerfile CMD exposes correctly.
